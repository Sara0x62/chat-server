async fn websocket(stream: WebSocket, state: Arc<AppState>) {
    let (mut sender, mut receiver) = stream.split();

    let mut rx = state.tx.subscribe();
    let tx = state.tx.clone();
    let tx2 = state.tx.clone();
    let mut tmp = state.clone();
    let mut username = String::new();
    let userb = username.clone();

    
    // Setup send task
    // Client <-> Server
    let mut send_task = tokio::spawn(
        async move {
            while let Ok(msg) = rx.recv().await {
                let reply: SocketMessage = match serde_json::from_str(&msg) {
                    Ok(m) => m,
                    Err(e) => {
                        generate_reply("error", "invalid json request")
                    },
                };

                info!("Got send_task: {:?}", reply);

                if reply.msg_type == "error" {
                    let msg = serde_json::to_string(&reply);
                    match msg {
                        Ok(msg) => {
                            if sender.send(Message::Text(msg)).await.is_err() {
                                info!("Unable to send reply of bad JSON request");
                                break;
                            }
                        },
                        Err(e) => {
                            info!("Unable to send reply of bad JSON request");
                        }
                    };
                }

                if reply.msg_type == "message" {                        
                    let msg = serde_json::to_string(&reply);
                    match msg {
                        Ok(msg) => {
                            if sender.send(Message::Text(msg)).await.is_err() {
                                info!("Unable to send reply of bad JSON request");
                                break;
                            }
                        },
                        Err(e) => {
                            info!("Unable to send reply of bad JSON request");
                        }
                    }
                }
                if reply.msg_type == "change" {
                }
                if reply.msg_type == "create" {
                    let name = &reply.content;
                    // check_username(&state, &mut username);
                    check_user_by_name(&tmp, &mut username, &name);

                    if !username.is_empty() {
                        let msg = serde_json::to_string(
                            &SocketMessage {
                                msg_type: "join_event".to_string(),
                                content: name.to_string(),
                                sender: name.to_string(),
                            }
                        ).unwrap();
                        let _ = tmp.tx.send(msg);
                    } else {
                        let reply = generate_reply("notif", "invalid json request");
                        let msg = serde_json::to_string(&reply);
                        match msg {
                            Ok(msg) => {
                                if sender.send(Message::Text(msg)).await.is_err() {
                                    info!("Unable to send reply of bad JSON request");
                                    break;
                                }
                            },
                            Err(e) => {
                                info!("Unable to send reply of bad JSON request");
                            }
                        };
                    }
                }
                if reply.msg_type == "join_event" {
                    let msg = serde_json::to_string(&reply).unwrap();
                    // let _ = sender.send(Message::Text(msg)).await;
                    // _ = tx2.send(msg);
                }
            }
        }
    );

    // Receives messages from socket
    // Broadcast to all users
    let mut recv_task = tokio::spawn(
        async move {
            while let Some(Ok(Message::Text(msg))) = receiver.next().await {
                let reply: SocketMessage = serde_json::from_str(&msg).unwrap();

                info!("Received {:?}", reply);
                if reply.msg_type == "message" {
                    info!("Broadcasting cause type == message");
                }
                let _ = tx.send(msg);
            }
        }
    );

    tokio::select! {
        _ = (&mut send_task) => recv_task.abort(),
        _ = (&mut recv_task) => send_task.abort(),
    };

    let msg = serde_json::to_string(
        &SocketMessage {
            msg_type: "message".to_string(),
            sender: userb.to_string(),
            content: "User left".to_string(),
        }
    ).unwrap();
    let _ = state.tx.send(msg);

    state.user_set.lock().unwrap().remove(&userb);
}